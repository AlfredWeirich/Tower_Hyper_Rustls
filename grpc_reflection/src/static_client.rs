//! src/static_client.rs
//!
//! This is an example of a standard, statically-typed gRPC client.
//! Unlike our Router (which figures out the schema at runtime), this client
//! knows the exact structure of the `system` service at compile time
//! because it imports the generated Rust code.
//!
//! This is how typical microservice-to-microservice communication looks in Rust.

pub mod system {
    // This macro reaches into the OUT_DIR (where build.rs wrote files)
    // and physically inserts the generated Rust code right here.
    // This gives us compile-time access to `IdentityServiceClient` and `LoginRequest`.
    tonic::include_proto!("system");
}

use system::HealthStatus;
use system::LoginRequest;
use system::MetricsQuery;
use system::identity_service_client::IdentityServiceClient;
use system::system_metrics_client::SystemMetricsClient;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. Create exactly ONE underlying HTTP/2 connection (Channel)
    let channel = tonic::transport::Endpoint::from_static("http://[::1]:50051")
        .connect()
        .await?;
    // 2. Clone that lightweight channel to as many different clients as you want!
    // Cloning a channel is extremely cheap. It does not open a new network connection.
    let mut identity_client = IdentityServiceClient::new(channel.clone());
    let mut metrics_client = SystemMetricsClient::new(channel.clone());

    // 2. Create the strongly-typed request defined in our .proto file
    let request = tonic::Request::new(LoginRequest {
        username: "admin".into(),
        password: "admin123".into(),
    });

    // 3. Make the gRPC call
    // The `.login()` method was automatically generated by tonic.
    // It handles taking our Rust struct, serializing it to binary Protobuf,
    // sending it over the network, waiting for the HTTP/2 response, and
    // deserializing the binary back into the `AuthTokenResponse` struct.
    let response = identity_client.login(request).await?;
    println!("RESPONSE={:?}", response.into_inner());


    // 4. anaother gRPC call
    let request = tonic::Request::new(MetricsQuery {
        include_cpu: true,
        include_memory: true,
    });

    let response = metrics_client.get_health(request).await?;
    let status = response.into_inner();
    println!("RESPONSE={:?}", status);
    Ok(())
}