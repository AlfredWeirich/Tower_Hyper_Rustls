//! src/router.rs
//!
//! This is the API Gateway / Router.
//! It achieves "Dynamic gRPC Transcoding": it accepts standard 
//! REST/JSON HTTP traffic
//! from the outside world exactly like a normal web server 
//! (e.g. from a browser).
//! It then uses a dynamically loaded schema (via gRPC Server Reflection) 
//! to translate
//! that JSON into highly compressed binary Protocol Buffers (gRPC), 
//! forwards it to
//! the backend microservice, and then translates the binary response 
//! back to JSON.
//!
//! This demonstrates how large tech companies put generic
//! "Envoy-like" proxies in front of gRPC microservices without 
//! forcing the proxy
//! to be recompiled every time a microservice changes its API.

use bytes::{BufMut, Bytes, BytesMut};
use http_body_util::{BodyExt, Full};
use hyper::server::conn::http1;
use hyper::service::service_fn;
use hyper::{Method, Request, Response, StatusCode, header};
use hyper_util::client::legacy::Client;
use hyper_util::client::legacy::connect::HttpConnector;
use hyper_util::rt::{TokioExecutor, TokioIo};
use prost::Message;
use prost_reflect::{DescriptorPool, DynamicMessage};
use serde::de::DeserializeSeed;
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::net::TcpListener;

use tokio_stream::wrappers::ReceiverStream;
use tonic::transport::Channel;

// Step 1.1: We manually tell rust to include the Reflection code 
// generated by build.rs
// so we have a `ServerReflectionClient` available!
pub mod reflection {
    tonic::include_proto!("grpc.reflection.v1");
}
use reflection::server_reflection_client::ServerReflectionClient;
use reflection::{ServerReflectionRequest, server_reflection_request::MessageRequest};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    println!("Router Core Booting...");

    // 1. BUILD THE DYNAMIC SCHEMA POOL VIA NETWORK REFLECTION
    // Instead of reading a local file, we connect to the running microservice
    // and ask it for its schema using the standardized 
    // Server Reflection protocol.
    let grpc_target_url = "http://[::1]:50051";
    println!(
        "Connecting to microservice at {} to fetch schema...",
        grpc_target_url
    );

    let channel = Channel::from_static(grpc_target_url).connect().await?;
    let mut reflection_client = ServerReflectionClient::new(channel);

    // 1.3: Ask the server for a list of all services it provides
    // The ServerReflection API is defined as a "Bidirectional Stream" (rpc ServerReflectionInfo(stream Req) returns (stream Res)).
    // Because Tonic requires a Rust `Stream` trait for streaming requests, we can't just pass a single struct.
    // We create an MPSC (Multi-Producer, Single-Consumer) channel as an adapter:
    // We drop our single request into the sender (`tx`), and hand the receiver (`rx`) to Tonic to read from.
    let (tx, rx) = tokio::sync::mpsc::channel(1);
    tx.send(ServerReflectionRequest {
        host: String::new(),
        message_request: Some(MessageRequest::ListServices(String::new())),
    })
    .await?;

    let response = reflection_client
        .server_reflection_info(tonic::Request::new(ReceiverStream::new(rx)))
        .await?;
    let mut response_stream = response.into_inner();

    let mut current_services = Vec::new();
    if let Some(res) = response_stream.message().await? {
        if let Some(
            reflection::server_reflection_response::MessageResponse::ListServicesResponse(list_res),
        ) = res.message_response
        {
            for service in list_res.service {
                current_services.push(service.name);
            }
        }
    }

    let mut pool = DescriptorPool::new();

    // 1.5: For every service we found, ask for the raw protobuf bytes
    for service_name in current_services {
        if service_name.starts_with("grpc.reflection") {
            continue; // Skip the reflection service itself
        }

        println!("Discovered service via Reflection: {}", service_name);

        // Again, adapt our single FileContainingSymbol request into the streaming API via MPSC
        let (tx, rx) = tokio::sync::mpsc::channel(1);
        tx.send(ServerReflectionRequest {
            host: String::new(),
            message_request: Some(MessageRequest::FileContainingSymbol(service_name)),
        })
        .await?;

        let response = reflection_client
            .server_reflection_info(tonic::Request::new(ReceiverStream::new(rx)))
            .await?;
        let mut response_stream = response.into_inner();

        if let Some(res) = response_stream.message().await? {
            if let Some(
                reflection::server_reflection_response::MessageResponse::FileDescriptorResponse(
                    fd_res,
                ),
            ) = res.message_response
            {
                for fd_bytes in fd_res.file_descriptor_proto {
                    // The grpc reflection api returns individual FileDescriptorProto packets,
                    // not a full FileDescriptorSet.
                    let fd_proto = prost::Message::decode(fd_bytes.as_ref())?;
                    pool.add_file_descriptor_proto(fd_proto)?;
                }
            }
        }
    }

    let pool = Arc::new(pool);
    println!("Dynamic schema pool built successfully over the network!");

    // 2. PREPARE THE HTTP/2 BACKEND CLIENT
    // gRPC requires HTTP/2. We configure Hyper to strictly use HTTP/2
    // when communicating with the internal microservices.
    let client: Client<HttpConnector, Full<Bytes>> = Client::builder(TokioExecutor::new())
        .http2_only(true)
        .build_http();
    let client = Arc::new(client);

    // 3. START THE PUBLIC EDGE ROUTER (HTTP/1.1 REST)
    // We bind a normal TCP socket to listen for standard Web requests.
    let addr: SocketAddr = ([127, 0, 0, 1], 8080).into();
    let listener = TcpListener::bind(addr).await?;
    println!("Gateway JSON Endpoint listening on http://{}", addr);

    loop {
        // Accept incoming generic HTTP connections from the outside world
        let (stream, _) = listener.accept().await?;
        let io = TokioIo::new(stream);
        let pool = pool.clone();
        let client = client.clone();

        // Spawn a background task to handle this specific connection
        tokio::spawn(async move {
            if let Err(err) = http1::Builder::new()
                .serve_connection(
                    io,
                    service_fn(move |req| {
                        // Forward the request to our translation logic
                        handle_json_to_grpc(
                            req,
                            "http://[::1]:50051".to_string(), // The internal backend IP
                            pool.clone(),
                            client.clone(),
                        )
                    }),
                )
                .await
            {
                eprintln!("Error handling connection: {:?}", err);
            }
        });
    }
}

/// The core translation engine.
/// Accepts JSON from the user, dynamically transcodes to binary Protobuf,
/// hits the backend, transcodes back to JSON, and replies.
async fn handle_json_to_grpc(
    req: Request<hyper::body::Incoming>,
    grpc_backend_url: String,
    pool: Arc<DescriptorPool>,
    client: Arc<Client<HttpConnector, Full<Bytes>>>,
) -> Result<Response<Full<Bytes>>, Box<dyn std::error::Error + Send + Sync>> {
    // ------------------------------------
    // STEP 1: ROUTING / DISCOVERY
    // ------------------------------------
    // We expect REST clients to POST to `/Package.Service/MethodName`
    // Example: /system.IdentityService/Login
    let uri_path = req.uri().path().to_string();
    let path = uri_path.trim_start_matches('/');
    let parts: Vec<&str> = path.split('/').collect();

    if req.method() != Method::POST || parts.len() != 2 {
        return Ok(Response::builder()
            .status(StatusCode::NOT_FOUND)
            .body(Full::new(Bytes::from(
                "Please use POST /Fully.Qualified.Service/Method!\n",
            )))?);
    }

    let service_name = parts[0];
    let method_name = parts[1];

    // Grab the schema for this specific method dynamically from the pool!
    // If the schema doesn't exist, this returns a 404 cleanly.
    let method_desc = match pool.get_service_by_name(service_name) {
        Some(s) => match s.methods().find(|m| m.name() == method_name) {
            Some(m) => m,
            None => {
                return Ok(Response::builder()
                    .status(404)
                    .body(Full::new(Bytes::from("Method Not Found\n")))?);
            }
        },
        None => {
            return Ok(Response::builder()
                .status(404)
                .body(Full::new(Bytes::from("Service Not Found\n")))?);
        }
    };

    let incoming_body = req.collect().await?.to_bytes();
    println!("Router intercepted JSON payload: {:?}", incoming_body);

    // ------------------------------------
    // STEP 2: TRANSLATE JSON -> PROTOBUF
    // ------------------------------------
    // Create a `DynamicMessage` which acts as a generic dictionary based on the schema.
    let mut deserializer = serde_json::Deserializer::from_slice(&incoming_body);

    // Validate the incoming JSON structure strictly against the Protobuf schema
    let dynamic_req_msg =
        match method_desc.input().deserialize(&mut deserializer) {
            Ok(msg) => msg,
            Err(e) => {
                return Ok(Response::builder().status(400).body(Full::new(Bytes::from(
                    format!("Invalid JSON payload: {}\n", e),
                )))?);
            }
        };

    // Serialize that validated dictionary directly into tightly-packed binary Protobuf bytes
    let mut protobuf_payload = BytesMut::new();
    dynamic_req_msg.encode(&mut protobuf_payload)?;

    // ------------------------------------
    // STEP 3: CONSTRUCT gRPC FRAMING
    // ------------------------------------
    // Since TCP is a continuous stream, gRPC requires exactly 5 bytes before every message
    // to tell the receiver exactly how long the upcoming message is.
    // [1 byte indicating if compressed] [4 bytes indicating payload length] [Payload]
    let mut grpc_frame = BytesMut::with_capacity(5 + protobuf_payload.len());
    grpc_frame.put_u8(0); // 0 = Not compressed
    grpc_frame.put_u32(protobuf_payload.len() as u32);
    grpc_frame.put_slice(&protobuf_payload);

    // ------------------------------------
    // STEP 4: SEND TO MICROSERVICE
    // ------------------------------------
    let grpc_uri = format!("{}/{}", grpc_backend_url, path);
    println!("Router sending gRPC request to: {}", grpc_uri);
    let grpc_req = Request::builder()
        .method(Method::POST)
        .uri(grpc_uri)
        .header(header::CONTENT_TYPE, "application/grpc") // Required for gRPC
        .header("te", "trailers") // Required for gRPC status codes
        .body(Full::new(grpc_frame.freeze()))?;

    // Fire off the HTTP/2 request
    let mut grpc_res = client.request(grpc_req).await?;

    if grpc_res.status() != StatusCode::OK {
        return Ok(Response::builder()
            .status(grpc_res.status())
            .body(Full::new(Bytes::from(format!(
                "Backend Error: {}\n",
                grpc_res.status()
            ))))?);
    }

    // ------------------------------------
    // STEP 5: RECEIVE gRPC BINARY
    // ------------------------------------
    let res_body_bytes = grpc_res.body_mut().collect().await?.to_bytes();

    // Verify it actually contains the 5-byte header
    if res_body_bytes.len() < 5 {
        return Ok(Response::builder()
            .status(502)
            .body(Full::new(Bytes::from("Invalid gRPC Response\n")))?);
    }

    // Parse the 4 bytes indicating length to extract only the payload
    let payload_len = u32::from_be_bytes(res_body_bytes[1..5].try_into().unwrap()) as usize;
    let raw_protobuf_res = &res_body_bytes[5..5 + payload_len];

    // ------------------------------------
    // STEP 6: TRANSLATE PROTOBUF -> JSON
    // ------------------------------------
    // Decode the raw binary back into a DynamicMessage dictionary based on the output schema
    let mut dynamic_res_msg = DynamicMessage::new(method_desc.output());
    if let Err(e) = dynamic_res_msg.merge(raw_protobuf_res) {
        return Ok(Response::builder()
            .status(502)
            .body(Full::new(Bytes::from(format!(
                "Failed to parse Protobuf: {}\n",
                e
            ))))?);
    }

    // Finally, transform it into standard JSON to send back to the REST client
    // DynamicMessage implements the Trait Serialize
    let response_json = serde_json::to_string(&dynamic_res_msg)?;
    println!("Router sending back JSON: {}", response_json);

    Ok(Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, "application/json")
        .body(Full::new(Bytes::from(response_json)))?)
}