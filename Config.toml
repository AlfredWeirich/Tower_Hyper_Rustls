###############################################################################
# GLOBAL SYSTEM SETTINGS
# These settings affect the overall performance and base identity of the gateway.
###############################################################################

# The number of worker threads for the Tokio async runtime.
# Default: (Available CPU Cores * 2). 
# Manual override is useful for high-performance tuning on dedicated hardware.
tokio_threads = 50

# The Base Object Identifier (OID) used for security validation.
# This acts as the root for interpreting client certificate extensions and JWT claims.
# Private Enterprise Number (PEN)
pki_base_oid = "1.3.6.1.4.1.65111"

[oid_mapping]
# Maps OID suffixes found in certificates/JWTs to internal application roles.
# Format: "suffix" = "RoleName" (Roles: Admin, Operator, Viewer, Guest, ...)
"1" = "Admin"
"2" = "Operator"
"3" = "Viewer"
"4" = "Guest"

# Directory path for persistent log files.
# If commented out or omitted, the application will only log to Standard Output (stdout).
# log_dir = "log"

###############################################################################
# SERVER INSTANCE DEFINITIONS
# You can define multiple [[Server]] blocks to run several listeners simultaneously.
###############################################################################

[[Server]]
# =============================================================================
# First Server
# =============================================================================

    # --- Network Configuration ---
    # A unique name used for identifying this instance in logs and metrics.
    name = "first_server" 
    
    # The network interface IP to bind to. 
    # Use "0.0.0.0" to listen on all interfaces, or a specific local IP.
    ip = "192.168.178.175"
    
    # The TCP port the server will listen on.
    port = 1336

    # Master switch for this server instance.
    enabled = true

    # --- Protocol & Security ---
    # 'http' or 'https'. If 'https' is used, [Server.server_certs] must be configured.
    protocol = "https"

    # Authentication method required for this server:
    # "None"       - No auth (Public)
    # "ClientCert" - Mutual TLS (mTLS). Requires [[Server.client_certs]]
    # "JWT"        - JSON Web Token. Requires [Server.Layers.JWT]
    authentication = "None"

    # The service type that handles the request after passing through layers:
    # "Echo"   - Returns the request data as-is (Debug/Health checks)
    # "Router" - Forwards requests to upstreams defined in [Server.ReverseRoutes]
    service = "Echo"

    # --- Middleware Layers ---
    # Defines the execution pipeline. Layers are executed in the order listed.
    [Server.Layers]
    # Options: "Timing", "Counter", "Logger", "Inspection", "JwtAuth", 
    #          "ConcurrencyLimit", "RateLimiter:Simple", "RateLimiter:TokenBucket"
    # enabled = ["Decompression","MaxPayload", "Logger",  "Inspection",  "Compression", "AltSvc"] 
    enabled = [] 

    # --- Decompression Bomb Protection ---
    [Server.Layers.Decompression]
    max_decompressed_bytes = 10485760  # 10 MB limit

    # --- TLS: Server Identity (For HTTPS) ---
    [Server.server_certs]
    # Path to the public certificate (or full chain) in PEM format.
    ssl_certificate = "./server_certs/self_signed/fullchain_self.pem"
    # Path to the unencrypted private key file in PEM format.
    ssl_certificate_key = "./server_certs/self_signed/privkey_self.pem"

    # --- TLS: Client Verification (For mTLS) ---
    # This is an array of tables. You can trust multiple Certificate Authorities.
    [[Server.client_certs]]
    # Path to the CA certificate used to verify client certificates.
    ssl_client_ca = "./client_certs/ca.cert.pem"
    # Optional: Path to a Certificate Revocation List (CRL).
    # ssl_client_crl = "./client_certs/ca.crl.pem"

    # --- JWT Configuration ---
    # Required only if authentication = "JWT" or "JwtAuth" is in layers.
    [Server.Layers.JWT]
    # LIST OF PATHS to public keys (PEM) used to verify JWT signatures.
    jwt_public_keys = ["./jwt/public_key.pem"]

    # --- Concurrency Management ---
    [Server.Layers.ConcurrencyLimit]
    # Maximum number of requests processed simultaneously by this server.
    max_concurrent_requests = 64

    [Server.Layers.MaxPayload]
    max_bytes = 1000 #  10485760  # 10 MB Limit

    # #########################################################################
    # --- Inspection Layer (Whitelist Regex) ---
    # Only requests matching these regex patterns will be passed to the service.
    # Format: "PathPrefix" = ["Regex1", "Regex2"]
    [Server.AllowedPathes.GET]
    "/"     = ["^/?$", "^/\\?name=.*$"] # Allows root and root with name query
    "/help" = ["^/help$"]
    "/name" = ["^/name\\??id=\\d+$"]      # Allows /name only with numeric ID

    [Server.AllowedPathes.POST]
    "/address" = ["^/address\\??city=[a-zA-Z]+$"]

    [Server.AllowedPathes.PUT]
    "/" = ["^/?$", "^/\\?id=\\d+$"]
    # #########################################################################

    # #########################################################################
    # --- Reverse Proxy Routing ---
    # Only active if service = "Router".

    [Server.ReverseRoutes]
    # Syntax: "/prefix" = { upstreams = ["host:port"], strategy = "RoundRobin", allowed_roles = ["Role1", "Role2"] }
    # "RoundRobin" (Default if omitted): Iterates through the upstreams one by one in order using a fast, thread-safe atomic counter.
    # "LeastConnections": Tracks the number of active, in-flight requests for every upstream and always routes new traffic to the server currently handling the fewest connections.
    # "Random": Uses a fast pseudo-random number generator to spray traffic randomly across all available upstreams.
    # "Sticky": Hashes the incoming client's IP address (SocketAddr) to predictably route the exact same clients to the exact same backend servers every time (Session Affinity).
    # Longest prefix matches first (e.g., "/help" is checked before "/").
    "/name"   = { upstreams = ["192.168.178.175:1337/name","192.168.178.175:1338/name"], strategy = "RoundRobin", allowed_roles = ["Admin"], cooldown_seconds = 5, max_retries = 3, active_health_check_interval = 15 }
    "/"       = { upstreams = ["192.168.178.175:1338", "192.168.178.175:1339"], strategy = "LeastConnections", allowed_roles = ["Admin", "Operator"] }
    "/help"   = { upstreams = ["192.168.178.175:1340/help","192.168.178.175:1341/help"], strategy = "RoundRobin", allowed_roles = ["Admin"] }

    # --- Upstream Connection Parameters ---
    [Server.RouterParams]
    # Protocol the gateway uses to talk to the backend (upstream).
    protocol = "https"
    # Auth method the gateway uses to authenticate against the backend.
    authentication = "None"
    # CA used by the gateway to verify the backend's identity.
    ssl_root_certificate = "./server_certs/self_signed/myca.pem"
    # Client certificate/key if the backend requires mTLS from the gateway.
    ssl_client_certificate = "./client_certs/client.cert.pem"
    ssl_client_key = "./client_certs/client.key.pem"
    # Optional: path to a JWT file if the backend requires JWT auth.
    # jwt = "./jwt/token.jwt"
    # #########################################################################


    # --- Rate Limiting: Simple ---
    [Server.Layers.RateLimiter]
    # Strict maximum requests per second allowed for this server.
    requests_per_second = 500000

    # --- Rate Limiting: Token Bucket ---
    [Server.Layers.TokenBucketRateLimiter]
    max_capacity = 15     # Maximum burst size (tokens)
    refill = 8           # Number of tokens added per interval
    duration_micros = 1000 # Refill interval in microseconds

    # --- Artificial Latency ---
    [Server.Layers.Delay]
    # Delays every request by this amount. Useful for debugging or throttling.
    delay_micros = 1000000

   


[[Server]]
# =============================================================================
# Second Server
# =============================================================================
            name = "scnd_server"
            ip = "192.168.178.175"
            port = 1337
            protocol = "https"
            service = "Echo"
            enabled = true
            authentication = "None"

            # [[Server.client_certs]]
            # ssl_client_ca = "./client_certs/ca.cert.pem"

            [Server.server_certs]
            ssl_certificate = "./server_certs/self_signed/fullchain_self.pem"
            ssl_certificate_key = "./server_certs/self_signed/privkey_self.pem"

            [Server.Layers]
            # Keeping layers empty for maximum throughput on the backend.
            enabled = ["Logger"]

[[Server]]
# =============================================================================
# Third Server
# =============================================================================
            name = "third_server"
            ip = "192.168.178.175"
            port = 1338
            protocol = "https"
            service = "Echo"
            enabled = true
            authentication = "None"

            # [[Server.client_certs]]
            # ssl_client_ca = "./client_certs/ca.cert.pem"

            [Server.server_certs]
            ssl_certificate = "./server_certs/self_signed/fullchain_self.pem"
            ssl_certificate_key = "./server_certs/self_signed/privkey_self.pem"

            [Server.Layers]
            # Keeping layers empty for maximum throughput on the backend.
            enabled = ["Logger"]

[[Server]]
# =============================================================================
# fourth Server
# =============================================================================
            name = "fourth_server"
            ip = "192.168.178.175"
            port = 1339
            protocol = "https"
            service = "Echo"
            enabled = true
            authentication = "None"

            # [[Server.client_certs]]
            # ssl_client_ca = "./client_certs/ca.cert.pem"

            [Server.server_certs]
            ssl_certificate = "./server_certs/self_signed/fullchain_self.pem"
            ssl_certificate_key = "./server_certs/self_signed/privkey_self.pem"

            [Server.Layers]
            # Keeping layers empty for maximum throughput on the backend.
            enabled = ["Logger"]

[[Server]]
# =============================================================================
# fifth Server
# =============================================================================
            name = "fifth_server"
            ip = "192.168.178.175"
            port = 1340
            protocol = "https"
            service = "Echo"
            enabled = true
            authentication = "None"

            # [[Server.client_certs]]
            # ssl_client_ca = "./client_certs/ca.cert.pem"

            [Server.server_certs]
            ssl_certificate = "./server_certs/self_signed/fullchain_self.pem"
            ssl_certificate_key = "./server_certs/self_signed/privkey_self.pem"

            [Server.Layers]
            # Keeping layers empty for maximum throughput on the backend.
            enabled = ["Logger"]

[[Server]]
# =============================================================================
# sixth Server
# =============================================================================
            name = "sixth_server"
            ip = "192.168.178.175"
            port = 1341
            protocol = "https"
            service = "Echo"
            enabled = true
            authentication = "None"

            # [[Server.client_certs]]
            # ssl_client_ca = "./client_certs/ca.cert.pem"

            [Server.server_certs]
            ssl_certificate = "./server_certs/self_signed/fullchain_self.pem"
            ssl_certificate_key = "./server_certs/self_signed/privkey_self.pem"

            [Server.Layers]
            # Keeping layers empty for maximum throughput on the backend.
            enabled = ["Logger"]
